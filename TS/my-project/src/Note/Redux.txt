Redux

1. Store
- Store là nơi lưu trữ toàn bộ trạng thái (state) của ứng dụng.
- Mỗi ứng dụng Redux chỉ có một Store duy nhất.
- Trạng thái trong Store là bất biến và chỉ được thay đổi thông qua Actions.

2. Action
- Action là một đối tượng mô tả một sự kiện xảy ra trong ứng dụng.
- Action có một thuộc tính bắt buộc là type (chuỗi mô tả hành động) và có thể có thêm dữ liệu (payload) để truyền thông tin.

3. Reducer
- Reducer là một hàm thuần (pure function) chịu trách nhiệm tính toán trạng thái mới dựa trên trạng thái hiện tại và một action.
- Reducer không được thay đổi trực tiếp trạng thái, mà phải tạo ra một bản sao mới của nó.

4. Dispatch
- Dispatch là phương thức được dùng để gửi một action đến Store.
- Khi dispatch một action, Store sẽ chuyển action đó đến các Reducers để tính toán trạng thái mới.

5. Selector
- Selector là hàm để truy xuất một phần trạng thái từ Store.
- Selector giúp tách biệt logic lấy dữ liệu với component.

Quy trình hoạt động của Redux
1. View: Người dùng thực hiện một hành động trong giao diện (ví dụ: nhấn nút thêm công việc).
2. Action: Một action được tạo ra và gửi đến Store thông qua dispatch.
3. Reducer: Reducer nhận action và trạng thái hiện tại, sau đó trả về trạng thái mới.
4. Store: Lưu trữ trạng thái mới và thông báo cho giao diện cập nhật.

---------------------------------

Vì sao sử dụng redux
- Quản lý trạng thái toàn cục một cách rõ ràng: duy trì trạng thái toàn cục của ứng dụng
trong một store duy nhất
- Khả năng xử lý bất đồng bộ (sử dụng middleware như Redux Thunk hoặc Redux Saga)
- Hỗ trọ Redux DevTools giúp theo dõi và debug các action, trạng thái và thay đổi trong ứng dụng
theo thời gian thực
- Redux dễ dàng mở rộng khi ứng dụng của bạn trở nên phức tạp hơn, 
vì cấu trúc actions và reducers rõ ràng giúp bạn mở rộng 
và thêm tính năng mới mà không làm rối loạn ứng dụng

Vậy ưu/nhược của redux, tại sao cần phải dùng nó
Ưu điểm:
- Quản lý state tập trung
   + Một store duy nhất cho toàn bộ ứng dụng
   + Dễ dàng debug và theo dõi thay đổi state

- Cập nhật state có thể dự đoán được
   + Luồng dữ liệu một chiều
   + State chỉ có thể thay đổi thông qua actions

- Tối ưu hóa hiệu suất
   + Tránh re-renders không cần thiết
   + Memoization và caching tích hợp

- Developer Tools tốt
   + Redux DevTools cho phép theo dõi state changes
   + Time-travel debugging

- Middleware Support
   + Xử lý side effects (Redux Thunk, Redux Saga)
   + Logging, routing, etc.

Nhược điểm:
- Boilerplate code nhiều
- Learning curve cao
- Có thể phức tạp cho ứng dụng nhỏ
- Setup ban đầu tốn thời gian

Trong cấu trúc redux thunk có Slice, vậy tại sao lại có nó, nó là kĩ thuật gì và dùng ntn?
- Cấu trúc Slice: là một cách để chia nhỏ trạng thái toàn cục của ứng dụng thành các phần (từng slice).
Mỗi slice quản lý một phần của trạng thái, bao gồm:
   + State: Trạng thái quản lý bởi slice đó.
   + Reducers: Các hàm để thay đổi trạng thái khi có action được gửi đến.
   + Actions: Các action creators tự động được tạo ra từ các reducers.

- Cần Slice trong Redux Toolkit vì:
   + Giảm Boilerplate Code
   + Tổ chức mã dễ dàng hơn: chia nhỏ các phần của store giúp mã dễ đọc và bảo trì hơn
   + Kết hợp với Thunk: kết hợp tốt với các middleware như Redux Thunk để xử lý tác vụ bất đồng bộ (ví dụ: gọi API).

- Slice là một kỹ thuật của Redux Toolkit để tổ chức code, nó kết hợp
reducer logic và actions trong một file

Phân biệt các thành phần: Store, Action, Reducers.
- Store:
   + Nơi lưu trữ state của ứng dụng
   + Singleton object
   + Cung cấp phương thức để access và update state

- Action:
   + Plain JavaScript objects mô tả what happened
   + Phải có type property
   + Payload là optional

- Reducers:
   + Pure functions xử lý state changes
   + Nhận state và action, trả về new state
   + Không được mutate state trực tiếp

Redux thunk có phá vỡ cấu trúc của Reactjs application truyền thống không? và tại sao không?
Redux Thunk không phá vỡ cấu trúc React traditional vì:
   - Tính module hóa:
    + Redux Thunk chỉ thêm middleware layer
    + Không thay đổi component structure

   - Luồng dữ liệu một chiều:
    + Vẫn duy trì luồng dữ liệu một chiều của React
    + Action -> Reducer -> State -> View

   - Kiến trúc dựa trên thành phần:
    + Components vẫn độc lập
    + Chỉ thêm cách quản lý state mới

   - Tách mối quan tâm:
    + Logic business được tách biệt vào thunks
    + UI logic vẫn ở components

1 component được re-render khi nào 
- Khi props hoặc state thay đổi
- Khi giá trị của context thay đổi nếu component sử dụng React Context
- Khi key của một component thay đổi trong một danh sách, React sẽ coi đó là
một component mới và thực hiện re-render
- Khi các deps của các hooks như useEffect, useCallback, hoặc useMemo thay đổi

Các cách truyền dữ liệu từ cha xuống con
- Truyền dữ liệu qua props
- Truyền dữ liệu qua context
- Truyền dữ liệu qua function as a child: một phương thức khác để truyền dữ liệu là qua render props. Bạn truyền một hàm từ cha xuống con
và con gọi hàm đó để lấy dữ liệu.
- Truyền dữ liệu qua callback function

React Query

1. Redux
-B1: Cài đặt thư viện "npm install redux react-redux"
-B2: Tạo Store (Chỉ có 1 store duy nhất)
   + Định nghĩa trạng thái ban đầu (initialState).
   + Tạo các reducer để cập nhật trạng thái dựa trên các action.
   (Không được sửa state trực tiếp phải copy ra state mới ...state)
   + Tạo store bằng createStore.
-B3: Kết nối Redux với React
   + Sử dụng Provider từ react-redux để bao bọc toàn bộ ứng dụng, truyền vào store
-B4: Tạo Actions (type -bắt buộc-, payload)
   + Định nghĩa các action để thay đổi trạng thái
-B5: Kết nối Component với Redux
   + Sử dụng useSelector để truy cập trạng thái từ store
   + Sử dụng useDispatch để gửi action

------------------------------------------

2. React Query
-B1: Cài đặt thư viện "npm install react-query"
-B2: Thiết lập QueryClient
   + Sử dụng QueryClientProvider bao bọc ứng dụng và truyền vào queryClient
-B3: Sử dụng useQuery
   + Fetch dữ liệu bằng useQuery

------------------------------------------

3. Zustand
-B1: Cài đặt thư viện "npm install zustand"
-B2: Tạo Store (Có thể tạo nhiều Store riêng việt và mỗi store có thể quản lý trạng thái độc lập)
   + Sử dụng Create (users, setUsers: không bắt buộc nhưng cần có 1 trong 2 
nếu không có cả 2 sẽ không có trạng thái hoặc hành động liên quan đến users) để định nghĩa trạng thái và actions
-B3: Sử dụng Store trong Component
   + Truy cập trạng thái và actions bằng hook useStore

------------------------------------------


4. Recoil
-B1: Cài đặt thư viện "npm install recoil"
-B2: Thiết lập RecoilRoot
   + Bao bọc ứng dụng bằng RecoilRoot
-B3: Định nghĩa Atom
   + Sử dụng atom để lưu trạng thái (key, default: hai thuộc tính đều cần thiết để định nghĩa một atom)
-B4: Sử dụng Atom trong Component
   + Sử dụng useRecoilState(hoạt động tương tự như useState trong React 
nhưng với trạng thái toàn cục được quản lý bởi Recoil) để đọc và thay đổi trạng thái

-------------------------------------------

5. MobX
-B1: Cài đặt thư viện "npm install mobx mobx-react-lite"
-B2: Tạo store (Có thể tạo nhiều store
và việc sử dụng nhiều store thường được áp dụng để tách biệt các phần khác nhau của trạng thái ứng dụng (state) nhằm dễ dàng quản lý)
   + Sử dụng makeAutoObservable để tạo trạng thái và actions
-B3: Sử dụng Store trong Component
   + Sử dụng observer để render lại component khi trạng thái thay đổi